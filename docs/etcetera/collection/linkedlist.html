<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<link type="text/css" href="http://www.nomad.so/ddoc/css/theme.css" rel="stylesheet" media="all" />
		<script type="text/javascript" src="http://www.nomad.so/ddoc/javascript/jquery-2.0.3.min.js"></script>
		<script type="text/javascript" src="http://www.nomad.so/ddoc/javascript/jquery.scrollTo.min.js"></script>
		<script type="text/javascript" src="http://www.nomad.so/ddoc/javascript/index.js"></script>
		<title>etcetera.collection.linkedlist</title>
	</head>
	<body>
		<h1>etcetera.collection.linkedlist</h1>
		<div class="sections"><p>Collection module.
</p>
<h3>License</h3><p>MIT. See LICENSE for full details.</p>
</div>
<div class="module-members"><h2><a name="LinkedList"></a>struct <span class="symbol">LinkedList</span>(T) if (is(T == Unqual!T));
</h2>
<div class="declaration-description"><div class="sections"><p>A generic doubly linked list implementation.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T</td>
<td>The type stored in each node in the list.</td></tr>
</table>
<h3>Examples</h3><p><pre>
<span class="keyword">import</span> std.algorithm;

<span class="keyword">auto</span> list = <span class="symbol">LinkedList</span>!(string)([<span class="string">"Qux"</span>, <span class="string">"Baz"</span>]);

list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">assert</span>(list.first == <span class="string">"Qux"</span>);
<span class="keyword">assert</span>(list.last == <span class="string">"Bar"</span>);
<span class="keyword">assert</span>(list.count == 4);
<span class="keyword">assert</span>(!list.empty);

<span class="keyword">assert</span>(list.byValue.canFind(<span class="string">"Baz"</span>));
<span class="keyword">assert</span>(list.byValue.retro.equal([<span class="string">"Bar"</span>, <span class="string">"Foo"</span>, <span class="string">"Baz"</span>, <span class="string">"Qux"</span>]));

list.clear();
<span class="keyword">assert</span>(list.empty);
<span class="keyword">assert</span>(list.count == 0);
</pre>
</p></div>
<div class="struct-members"><h2><a name="LinkedList.this"></a>this(T[] items);
</h2>
<div class="declaration-description"><div class="sections"><p>Construct a new linked list.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T[] items</td>
<td>An array of items to initialise the collection with.</td></tr>
</table>
</div>
</div>
<h2><a name="LinkedList.count"></a>const pure @property size_t <span class="symbol">count</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Get the number of items stored in the list.
</p>
<h3>Return Value</h3><p>The number of items stored in the list.</p>
</div>
</div>
<h2><a name="LinkedList.empty"></a>const pure @property bool <span class="symbol">empty</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Test if the list is <span class="symbol">empty</span> or not.
</p>
<h3>Return Value</h3><p><strong>true</strong> if the list is <span class="symbol">empty</span>, <strong>false</strong> if not.</p>
</div>
</div>
<h2><a name="LinkedList.insertFirst"></a>void <span class="symbol">insertFirst</span>(T item);
</h2>
<div class="declaration-description"><div class="sections"><p>Insert a new item at the beginning of the list.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T item</td>
<td>The item to insert.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>OutOfMemoryError</td><td>If memory allocation fails.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.first"></a>pure @property T <span class="symbol">first</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Get the <span class="symbol">first</span> item in the list.
</p>
<h3>Return Value</h3><p>The <span class="symbol">first</span> item in the list.

</p>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If the list is empty.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.removeFirst"></a>void <span class="symbol">removeFirst</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Remove the first item in the list.</p>
</div>
</div>
<h2><a name="LinkedList.insertLast"></a>void <span class="symbol">insertLast</span>(T item);
</h2>
<div class="declaration-description"><div class="sections"><p>Insert a new item at the end of the list.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T item</td>
<td>The item to insert.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>OutOfMemoryError</td><td>If memory allocation fails.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.last"></a>pure @property T <span class="symbol">last</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Get the <span class="symbol">last</span> item in the list.
</p>
<h3>Return Value</h3><p>The <span class="symbol">last</span> item in the list.

</p>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If the list is empty.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.removeLast"></a>void <span class="symbol">removeLast</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Remove the last item in the list.</p>
</div>
</div>
<h2><a name="LinkedList.insert"></a>void <span class="symbol">insert</span>(T item, size_t index);
</h2>
<div class="declaration-description"><div class="sections"><p>Insert a new item at the specified index. The index must be between (and
 including) 0 and the number returned by the count method.
</p>
<p>This method uses a linear search to find the index in the list. The only
 optimisation done is that if the index is past half way, the search
 starts from the last item and works backwards.

</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T item</td>
<td>The item to <span class="symbol">insert</span>.</td></tr>
<tr><td>size_t index</td>
<td>The index in which to <span class="symbol">insert</span> the item.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If index is outside of limits.</td></tr>
         <tr><td>OutOfMemoryError</td><td>If memory allocation fails.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.get"></a>pure T <span class="symbol">get</span>(size_t index);
</h2>
<div class="declaration-description"><div class="sections"><p>Get the item at the specified index. The index must be between (and
 including) 0 and be below the number returned by the count method.
</p>
<p>This method uses a linear search to find the index in the list. The only
 optimisation done is that if the index is past half way, the search
 starts from the last item and works backwards.

</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>size_t index</td>
<td>The index of the item to return.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If index is outside of limits.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.update"></a>pure void <span class="symbol">update</span>(size_t index, T item);
</h2>
<div class="declaration-description"><div class="sections"><p>Update the item at the specified index. The index must be between (and
 including) 0 and be below the number returned by the count method.
</p>
<p>This method uses a linear search to find the index in the list. The only
 optimisation done is that if the index is past half way, the search
 starts from the last item and works backwards.

</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>size_t index</td>
<td>The index of the item to <span class="symbol">update</span>.</td></tr>
<tr><td>T item</td>
<td>The new item to insert.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If index is outside of limits.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.remove"></a>void <span class="symbol">remove</span>(size_t index);
</h2>
<div class="declaration-description"><div class="sections"><p>Remove the item at the specified index. The index must be between (and
 including) 0 and be below the number returned by the count method.
</p>
<p>This method uses a linear search to find the index in the list. The only
 optimisation done is that if the index is past half way, the search
 starts from the last item and works backwards.

</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>size_t index</td>
<td>The index of the item to <span class="symbol">remove</span>.</td></tr>
</table>
<h3>Exceptions Thrown</h3><p><table class="parameter-list">         <tr><td>AssertError</td><td>If index is outside of limits.</td></tr>
     </table></p>
</div>
</div>
<h2><a name="LinkedList.contains"></a>pure bool <span class="symbol">contains</span>(T item);
</h2>
<div class="declaration-description"><div class="sections"><p>Check if a value is contained in the list.
</p>
<p>This is a simple linear search and can take quite some time with large
 lists.

</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>T item</td>
<td>The item to find in the list.</td></tr>
</table>
<h3>Return Value</h3><p><strong>true</strong> if the item is found on the list, <strong>false</strong> if not.</p>
</div>
</div>
<h2><a name="LinkedList.clear"></a>void <span class="symbol">clear</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Clears the list and deallocates all memory used by the nodes.</p>
</div>
</div>
<h2><a name="LinkedList.byValue"></a>pure auto <span class="symbol">byValue</span>();
</h2>
<div class="declaration-description"><div class="sections"><p>Return a bidirectional range to allow this list to be used with various
 other algorithms.
</p>
<h3>Return Value</h3><p>A bidirectional range representing this list.

</p>
<p><h3>Example:</h3>
<pre><span class="keyword">import</span> std.algorithm;
<span class="keyword">import</span> std.array;
<span class="keyword">import</span> std.string;

<span class="keyword">auto</span> list = LinkedList!(string)([]);

list.insertLast(<span class="string">"Qux"</span>);
list.insertLast(<span class="string">"Baz"</span>);
list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">assert</span>(list.<span class="symbol">byValue</span>.canFind(<span class="string">"Baz"</span>));
<span class="keyword">assert</span>(list.<span class="symbol">byValue</span>.retro.map!(toLower).equal([<span class="string">"bar"</span>, <span class="string">"foo"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>]));
</pre>
</p>
</div>
</div>
<h2><a name="LinkedList.opApply"></a>int <span class="symbol">opApply</span>(scope int delegate(ref T) nothrow @nogc dg);
</h2>
<div class="declaration-description"><div class="sections"><p>Enable forward iteration in foreach loops.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>int delegate(ref T) nothrow @nogc dg</td>
<td>A delegate that replaces the foreach loop.</td></tr>
</table>
<h3>Return Value</h3><p>A return value to determine if the loop should continue.

</p>
<h3>See Also</h3><p><a href="http://ddili.org/ders/d.en/foreach_opapply.html">http://ddili.org/ders/d.en/foreach_opapply.html</a>

</p>
<p><h3>Example:</h3>
<pre><span class="keyword">import</span> std.stdio;

<span class="keyword">auto</span> list = LinkedList!(string)([]);

list.insertLast(<span class="string">"Qux"</span>);
list.insertLast(<span class="string">"Baz"</span>);
list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">foreach</span> (value; list)
{
	writefln(<span class="string">"%s"</span>, value);
}
</pre>
</p>
</div>
</div>
<h2><a name="LinkedList.opApply.2"></a>int <span class="symbol">opApply</span>(scope int delegate(ref size_t, ref T) nothrow @nogc dg);
</h2>
<div class="declaration-description"><div class="sections"><p>Enable forward iteration in foreach loops using an index.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>int delegate(ref size_t, ref T) nothrow @nogc dg</td>
<td>A delegate that replaces the foreach loop.</td></tr>
</table>
<h3>Return Value</h3><p>A return value to determine if the loop should continue.

</p>
<h3>See Also</h3><p><a href="http://ddili.org/ders/d.en/foreach_opapply.html">http://ddili.org/ders/d.en/foreach_opapply.html</a>

</p>
<p><h3>Example:</h3>
<pre><span class="keyword">import</span> std.stdio;

<span class="keyword">auto</span> list = LinkedList!(string)([]);

list.insertLast(<span class="string">"Qux"</span>);
list.insertLast(<span class="string">"Baz"</span>);
list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">foreach</span> (index, value; list)
{
	writefln(<span class="string">"%s: %s"</span>, index, value);
}
</pre>
</p>
</div>
</div>
<h2><a name="LinkedList.opApplyReverse"></a>int <span class="symbol">opApplyReverse</span>(scope int delegate(ref T) nothrow @nogc dg);
</h2>
<div class="declaration-description"><div class="sections"><p>Enable reverse iteration in foreach loops.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>int delegate(ref T) nothrow @nogc dg</td>
<td>A delegate that replaces the foreach loop.</td></tr>
</table>
<h3>Return Value</h3><p>A return value to determine if the loop should continue.

</p>
<h3>See Also</h3><p><a href="http://ddili.org/ders/d.en/foreach_opapply.html">http://ddili.org/ders/d.en/foreach_opapply.html</a>

</p>
<p><h3>Example:</h3>
<pre><span class="keyword">import</span> std.stdio;

<span class="keyword">auto</span> list = LinkedList!(string)([]);

list.insertLast(<span class="string">"Qux"</span>);
list.insertLast(<span class="string">"Baz"</span>);
list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">foreach_reverse</span> (value; list)
{
	writefln(<span class="string">"%s"</span>, value);
}
</pre>
</p>
</div>
</div>
<h2><a name="LinkedList.opApplyReverse.2"></a>int <span class="symbol">opApplyReverse</span>(scope int delegate(ref size_t, ref T) nothrow @nogc dg);
</h2>
<div class="declaration-description"><div class="sections"><p>Enable reverse iteration in foreach loops using an index.
</p>
<h3>Parameters</h3><table class="parameter-list"><tr><td>int delegate(ref size_t, ref T) nothrow @nogc dg</td>
<td>A delegate that replaces the foreach loop.</td></tr>
</table>
<h3>Return Value</h3><p>A return value to determine if the loop should continue.

</p>
<h3>See Also</h3><p><a href="http://ddili.org/ders/d.en/foreach_opapply.html">http://ddili.org/ders/d.en/foreach_opapply.html</a>

</p>
<p><h3>Example:</h3>
<pre><span class="keyword">import</span> std.stdio;

<span class="keyword">auto</span> list = LinkedList!(string)([]);

list.insertLast(<span class="string">"Qux"</span>);
list.insertLast(<span class="string">"Baz"</span>);
list.insertLast(<span class="string">"Foo"</span>);
list.insertLast(<span class="string">"Bar"</span>);

<span class="keyword">foreach_reverse</span> (index, value; list)
{
	writefln(<span class="string">"%s: %s"</span>, index, value);
}
</pre>
</p>
</div>
</div>
</div>
</div>
</div>

	</body>
</html>
